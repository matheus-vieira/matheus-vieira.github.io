---
layout: interview_question
order: 155
tags:
- pwa
- progressive-web-apps
- service-worker
- web-manifest
- offline
- push-notifications
- web-development
title: What are Progressive Web Apps (PWAs) e How implementá-las
---

## Introduction Progressive Web Apps (PWAs) são applications web que withbinam o melhor das applications web tradicionais with resources nativos de aplicativos móveis. Elas utilizam tecnologias web modernas for offersr experiências similares às de aplicativos nativos, includesndo funcionamento offline, notificações push e installsção no dispositivo. ## Key Concept Uma PWA é construída about três pilares fundamentais: ser **reliable** (funciona offline), **Rápida** (respWhere rapidamente às interações) e **Envolvente** (offers experiência imersiva). Isso é alcançado mainmente through de Service Workers, Web App Manifest e HTTPS How requirements basic. ## Tópicos Relevbefore ### withponentes main de uma PWA **1. Service Worker** ```javascript // sw.js - Service Worker basic const CACHE_NAME = 'my-pwa-v1'; const urlsToCache = [ '/', '/styles/main.css', '/script/main.js', '/images/logo.png', '/offline.html' ]; // installsção do Service Worker self.addEventListener('install', (event) => { event.waitUntil( caches.open(CACHE_NAME) .then((cache) => { console.log('Cache aberto'); return cache.addAll(urlsToCache); }) ); }); // Interceptação de requisições self.addEventListener('fetch', (event) => { event.respondWith( caches.match(event.request) .then((response) => { // Retorna do cache se dispolevel if (response) { return response; } return fetch(event.request).catch(() => { // Fallback for página offline if (event.request.destination === 'document') { return caches.match('/offline.html'); } }); }) ); }); // updatesção do Service Worker self.addEventListener('activate', (event) => { event.waitUntil( caches.keys().then((cacheNames) => { return Promise.all( cacheNames.map((cacheName) => { if (cacheName !== CACHE_NAME) { return caches.delete(cacheName); } }) ); }) ); }); ``` **2. Web App Manifest** ```json { "name": "Minha Progressive Web App", "short_name": "MinhaPWA", "description": "Uma application web progressiva exemplar", "start_url": "/", "display": "standalone", "theme_color": "#2196F3", "background_color": "#ffffff", "orientation": "portrait", "scope": "/", "icons": [ { "src": "/images/icon-192x192.png", "sizes": "192x192", "type": "image/png", "purpose": "maskable any" }, { "src": "/images/icon-512x512.png", "sizes": "512x512", "type": "image/png" } ], "categories": ["productivity", "utilities"], "shortcuts": [ { "name": "Nova Tarefa", "url": "/new-task", "icons": [ { "src": "/images/new-task-icon.png", "sizes": "96x96" } ] } ] } ``` **3. Registro do Service Worker** ```javascript // main.js - Registro do Service Worker if ('serviceWorker' in navigator) { window.addEventListener('load', () => { navigator.serviceWorker.register('/sw.js') .then((registration) => { console.log('SW registrado with sucesso:', registration); // Verificar por updates registration.addEventListener('updatefound', () => { const newWorker = registration.installing; newWorker.addEventListener('statechange', () => { if (newWorker.state === 'installed' && navigator.serviceWorker.controller) { showUpdateAvailable(); } }); }); }) .catch((error) => { console.log('Falha no registro do SW:', error); }); }); } function showUpdateAvailable() { const updateBanner = document.createElement('div'); updateBanner.innerHTML = ` <div class="update-banner"> <p>Nova version dispolevel!</p> <button onclick="updateApp()">updatesr</button> <button onclick="dismissUpdate()">Debecause</button> </div> `; document.body.appendChild(updateBanner); } function updateApp() { if (navigator.serviceWorker.controller) { navigator.serviceWorker.controller.postMessage({ action: 'skipWaiting' }); } window.location.reload(); } ``` ### Estruntilgias de Cache avançadas ```javascript // Estruntilgias de cache no Service Worker const CACHE_STRATEGIES = { CACHE_FIRST: 'cache-first', NETWORK_FIRST: 'network-first', STALE_WHILE_REVALIDATE: 'stale-while-revalidate', NETWORK_ONLY: 'network-only', CACHE_ONLY: 'cache-only' }; // Cache First - for resources estáticos const cacheFirst = async (request) => { const cache = await caches.open(CACHE_NAME); const cachedResponse = await cache.match(request); if (cachedResponse) { return cachedResponse; } const networkResponse = await fetch(request); cache.put(request, networkResponse.clone()); return networkResponse; }; // Network First - for dados dinâmicos const networkFirst = async (request) => { const cache = await caches.open(CACHE_NAME); try { const networkResponse = await fetch(request); cache.put(request, networkResponse.clone()); return networkResponse; } catch (error) { const cachedResponse = await cache.match(request); if (cachedResponse) { return cachedResponse; } throw error; } }; // Stale While Revalidate - for resources que podem ser updated const staleWhileRevalidate = async (request) => { const cache = await caches.open(CACHE_NAME); const cachedResponse = await cache.match(request); const fetchPromise = fetch(request).then((networkResponse) => { cache.put(request, networkResponse.clone()); return networkResponse; }); return cachedResponse || fetchPromise; }; // apply estruntilgias baseadas na URL self.addEventListener('fetch', (event) => { const { request } = event; const url = new URL(request.url); if (url.pathname.startsWith('/api/')) { // API calls: Network First event.respondWith(networkFirst(request)); } else if (url.pathname.match(/\.(css|js|png|jpg|jpeg|svg)$/)) { // Static assets: Cache First event.respondWith(cacheFirst(request)); } else if (url.pathname.startsWith('/data/')) { // Data that can be stale: Stale While Revalidate event.respondWith(staleWhileRevalidate(request)); } else { // Default strategy event.respondWith(networkFirst(request)); } }); ``` ### Notificações Push ```javascript // configuresção de Push Notifications class PushNotificationManager { constructor() { this.publicVapidKey = 'BM8NvVrP9vkGPzDbJQY4nBcvX4Qa_sD7Ds6Eq3PkHBdMR8ZFGvYe5C8mJqb5-Rh1wGpKZc3oF2vM1nN5aE7Q'; } async requestPermission() { const permission = await Notification.requestPermission(); if (permission === 'granted') { console.log('Permissão for notificações concedida'); return this.subscribeToPush(); } else { console.log('Permissão for notificações negada'); return null; } } async subscribeToPush() { if (!('serviceWorker' in navigator)) { throw new Error('Service Worker não supportsdo'); } const registration = await navigator.serviceWorker.ready; const subscription = await registration.pushManager.subscribe({ userVisibleOnly: true, applicationServerKey: this.urlBase64ToUint8Array(this.publicVapidKey) }); // Enviar subscription for o servidor await this.sendSubscriptionToServer(subscription); return subscription; } async sendSubscriptionToServer(subscription) { await fetch('/api/push/subscribe', { method: 'POST', headers: { 'Content-Type': 'application/json', }, body: JSON.stringify(subscription) }); } urlBase64ToUint8Array(base64String) { const padding = '='.repeat((4 - base64String.length % 4) % 4); const base64 = (base64String + padding) .replace(/-/g, '+') .replace(/_/g, '/'); const rawData = window.atob(base64); const outputArray = new Uint8Array(rawData.length); for (let i = 0; i < rawData.length; ++i) { outputArray[i] = rawData.charCodeAt(i); } return outputArray; } } // No Service Worker - tratamento de notificações self.addEventListener('push', (event) => { const options = { body: 'Nova mensagem dispolevel!', icon: '/images/notification-icon.png', badge: '/images/notification-badge.png', vibrate: [200, 100, 200], data: { dateOfArrival: Date.now(), primaryKey: 1 }, actions: [ { action: 'explore', title: 'Ver detalhes', icon: '/images/checkmark.png' }, { action: 'close', title: 'Fechar', icon: '/images/xmark.png' } ] }; if (event.data) { const data = event.data.json(); options.body = data.message; options.data = data; } event.waitUntil( self.registration.showNotification('PWA Notification', options) ); }); self.addEventListener('notificationclick', (event) => { event.notification.close(); if (event.action === 'explore') { event.waitUntil( clients.openWindow('/details') ); } else if (event.action === 'close') { // Notification is closed, do nothing } else { // Default action event.waitUntil( clients.openWindow('/') ); } }); ``` ## Practical Example implementsção withpleta de uma PWA de lista de tarefas: ```html <!-- index.html --> <!DOCTYPE html> <html lang="pt-BR"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Todo PWA</title> <!-- PWA Meta Tags --> <meta name="theme-color" content="#2196F3"> <meta name="apple-mobile-web-app-capable" content="yes"> <meta name="apple-mobile-web-app-status-bar-style" content="default"> <meta name="apple-mobile-web-app-title" content="Todo PWA"> <!-- Manifest --> <link rel="manifest" href="/manifest.json"> <!-- Icons --> <link rel="apple-touch-icon" href="/images/icon-192x192.png"> <link rel="stylesheet" href="/styles/main.css"> </head> <body> <div id="app"> <header> <h1>Todo PWA</h1> <button id="installBtn" class="install-btn" style="display: none;"> installsr App </button> </header> <main> <div class="add-todo"> <input type="text" id="todoInput" placeholder="Nova tarefa..."> <button id="addBtn">Adicionar</button> </div> <div class="sync-status" id="syncStatus"> <span class="status-text">Online</span> </div> <ul id="todoList" class="todo-list"> <!-- Tarefas serão inseridas aqui --> </ul> </main> </div> <script src="/scripts/db.js"></script> <script src="/scripts/sync.js"></script> <script src="/scripts/app.js"></script> </body> </html> ``` ```javascript // scripts/db.js - IndexedDB for persistência offline class TodoDB { constructor() { this.dbName = 'TodoPWA'; this.version = 1; this.db = null; } async init() { return new Promise((resolve, reject) => { const request = indexedDB.open(this.dbName, this.version); request.onerror = () => reject(request.error); request.onsuccess = () => { this.db = request.result; resolve(this.db); }; request.onupgradeneeded = (event) => { const db = event.target.result; if (!db.objectStoreNames.contains('all')) { const store = db.createObjectStore('all', { keyPath: 'id', autoIncrement: true }); store.createIndex('timestamp', 'timestamp', { unique: false }); store.createIndex('synced', 'synced', { unique: false }); } }; }); } async addTodo(todo) { const transaction = this.db.transaction(['all'], 'readwrite'); const store = transaction.objectStore('all'); const todoWithMeta = { ...todo, timestamp: Date.now(), synced: false }; return store.add(todoWithMeta); } async getAllall() { const transaction = this.db.transaction(['all'], 'readonly'); const store = transaction.objectStore('all'); return new Promise((resolve, reject) => { const request = store.getAll(); request.onsuccess = () => resolve(request.result); request.onerror = () => reject(request.error); }); } async updateTodo(id, updates) { const transaction = this.db.transaction(['all'], 'readwrite'); const store = transaction.objectStore('all'); const todo = await this.getTodo(id); const updatedTodo = { ...todo, ...updates }; return store.put(updatedTodo); } async deleteTodo(id) { const transaction = this.db.transaction(['all'], 'readwrite'); const store = transaction.objectStore('all'); return store.delete(id); } async getUnsyncedall() { const transaction = this.db.transaction(['all'], 'readonly'); const store = transaction.objectStore('all'); const index = store.index('synced'); return new Promise((resolve, reject) => { const request = index.getAll(false); request.onsuccess = () => resolve(request.result); request.onerror = () => reject(request.error); }); } } ``` ```javascript // scripts/sync.js - Sincronização em background class BackgroundSync { constructor(db) { this.db = db; this.setupBackgroundSync(); } setupBackgroundSync() { if ('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) { navigator.serviceWorker.ready.then((registration) => { return registration.sync.register('background-sync'); }); } } async syncData() { if (!navigator.onLine) { console.log('Offline - sync adiado'); return; } const unsyncedall = await this.db.getUnsyncedall(); for (const todo of unsyncedall) { try { await this.syncTodo(todo); await this.db.updateTodo(todo.id, { synced: true }); } catch (error) { console.error('Erro ao sincronizar:', error); } } } async syncTodo(todo) { const response = await fetch('/api/all', { method: 'POST', headers: { 'Content-Type': 'application/json', }, body: JSON.stringify(todo) }); if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); } return response.json(); } } // No Service Worker self.addEventListener('sync', (event) => { if (event.tag === 'background-sync') { event.waitUntil( // implementsr lógica de sincronização syncPendingData() ); } }); async function syncPendingData() { // Abrir IndexedDB e sincronizar dados pendentes console.log('executesndo sincronização em background'); } ``` ```javascript // scripts/app.js - application main class TodoApp { constructor() { this.db = new TodoDB(); this.backgroundSync = null; this.deferredPrompt = null; this.init(); } async init() { await this.db.init(); this.backgroundSync = new BackgroundSync(this.db); this.setupEventListeners(); this.setupInstallPrompt(); this.loadall(); this.updateOnlineStatus(); // Registrar Service Worker if ('serviceWorker' in navigator) { navigator.serviceWorker.register('/sw.js'); } } setupEventListeners() { document.getElementById('addBtn').addEventListener('click', () => this.addTodo()); document.getElementById('todoInput').addEventListener('keypress', (e) => { if (e.key === 'Enter') this.addTodo(); }); window.addEventListener('online', () => this.updateOnlineStatus()); window.addEventListener('offline', () => this.updateOnlineStatus()); } setupInstallPrompt() { window.addEventListener('beforeinstallprompt', (e) => { e.preventDefault(); this.deferredPrompt = e; document.getElementById('installBtn').style.display = 'block'; }); document.getElementById('installBtn').addEventListener('click', () => { if (this.deferredPrompt) { this.deferredPrompt.prompt(); this.deferredPrompt.userChoice.then((result) => { if (result.outwithe === 'accepted') { console.log('PWA installsda'); } this.deferredPrompt = null; document.getElementById('installBtn').style.display = 'none'; }); } }); } async addTodo() { const input = document.getElementById('todoInput'); const text = input.value.trim(); if (!text) return; const todo = { text, withpleted: false, createdAt: new Date().toISOString() }; await this.db.addTodo(todo); input.value = ''; this.loadall(); // Tentar sincronizar imediatamente se online if (navigator.onLine) { this.backgroundSync.syncData(); } } async loadall() { const all = await this.db.getAllall(); const todoList = document.getElementById('todoList'); todoList.innerHTML = all.map(todo => ` <li class="todo-item ${todo.withpleted ? 'withpleted' : ''}"> <span class="todo-text">${todo.text}</span> <div class="todo-actions"> <button onclick="app.toggleTodo(${todo.id})" class="toggle-btn"> ${todo.withpleted ? '↶' : '✓'} </button> <button onclick="app.deleteTodo(${todo.id})" class="delete-btn"> 🗑️ </button> ${!todo.synced ? '<span class="sync-indicator">⏳</span>' : ''} </div> </li> `).join(''); } async toggleTodo(id) { const all = await this.db.getAllall(); const todo = all.find(t => t.id === id); if (todo) { await this.db.updateTodo(id, { withpleted: !todo.withpleted, synced: false }); this.loadall(); } } async deleteTodo(id) { await this.db.deleteTodo(id); this.loadall(); } updateOnlineStatus() { const statusElement = document.getElementById('syncStatus'); const isOnline = navigator.onLine; statusElement.innerHTML = ` <span class="status-text ${isOnline ? 'online' : 'offline'}"> ${isOnline ? 'Online' : 'Offline'} </span> `; if (isOnline) { this.backgroundSync.syncData(); } } } // Inicializar application const app = new TodoApp(); ``` ## benefits ### 1. **Experiência offline withpleta** - functionality mantida without conexão - Sincronização automática When online - Cache inteligente de resources ### 2. **Performance superior** - Carregamento instantâneo de resources cached - Lazy loading de resources não críticos - optimizesção automática de requests ### 3. **Engajamento nativo** - installsção no dispositivo - Notificações push - Integração with sistema operacional ### 4. **Baixo cost de development** - Uso de tecnologias web existentes - Uma base de code for múltiplas platforms - updates automáticas ### 5. **SEO e descoberta** - Indexável por motores de busca - URLs withpartilháveis - Progressive enhancement ## Considerações de implementsção ### **requirements mínimos:** - HTTPS obrigatório - Service Worker funcional - Web App Manifest válido - Design responsivo ### **Estruntilgias de cache:** - Cache First for resources estáticos - Network First for dados dinâmicos - Stale While Revalidate for resources atualizáveis ### **limitations:** - Suporte limitado em some browsers - Restrições de iOS Safari - Tamanho de cache limitado - withplexidade de management de estado offline