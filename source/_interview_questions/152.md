--- layout: interview_question title: how" implement o padrão Decorator and in quais situações utilizá-lo" tags: [design-patterns, decorator, gof, structural-patterns, oop, extensibility, composition, behavioral] order: 152 --- ## Introdução O padrão Decorator is um padrão estrutural que allows adicionar novos comportamentos a objetos existentes of forma dinâmica, envolvendo-os in objetos especiais que contêm os comportamentos. Is uma alternativa flexível à herança to estender funcionalidades. ## Conceito-chave O Decorator opera in the princípio of composição sobre herança, permitindo que comportamentos sejam anexados and removidos of objetos in tempo of execução. Ele mantém a mesma interface of the objeto original, mas adiciona responsabilidades adicionais through of uma cadeia of decoradores. ## Tópicos Relevantes ### Estrutura of the padrão ```csharp // Component - interface or class abstrata public interface IComponent { string Operation(); } // ConcreteComponent - implementation base public class ConcreteComponent : IComponent { public virtual string Operation() { return "ConcreteComponent"; } } // Decorator base public abstract class BaseDecorator : IComponent { protected IComponent _component; public BaseDecorator(IComponent component) { _component = component; } public virtual string Operation() { return _component?.Operation() ?? string.Empty; } } // ConcreteDecorators - implementações específicas public class ConcreteDecoratorA : BaseDecorator { public ConcreteDecoratorA(IComponent component) : base(component) { } public override string Operation() { return $"ConcreteDecoratorA({base.Operation()})"; } } public class ConcreteDecoratorB : BaseDecorator { public ConcreteDecoratorB(IComponent component) : base(component) { } public override string Operation() { return $"ConcreteDecoratorB({base.Operation()})"; } public string ExtraFeature() { return "ExtraFeature"; } } ``` ### Exemplo prático - Sistema of notificações ```csharp // Interface base to notificações public interface INotifier { void Send(string message); } // Implementation básica por email public class EmailNotifier : INotifier { private string email; public EmailNotifier(string email) { this.email = email; } public void Send(string message) { Console.WriteLine($"Enviando email to {email}: {message}"); } } // Decorator base public abstract class NotifierDecorator : INotifier { protected INotifier notifier; public NotifierDecorator(INotifier notifier) { this.notifier = notifier; } public virtual void Send(string message) { notifier.Send(message); } } // Decorator to SMS public class SMSDecorator : NotifierDecorator { private string phoneNumber; public SMSDecorator(INotifier notifier, string phoneNumber) : base(notifier) { this.phoneNumber = phoneNumber; } public override void Send(string message) { base.Send(message); Console.WriteLine($"Enviando SMS to {phoneNumber}: {message}"); } } // Decorator to Slack public class SlackDecorator : NotifierDecorator { private string slackChannel; public SlackDecorator(INotifier notifier, string slackChannel) : base(notifier) { this.slackChannel = slackChannel; } public override void Send(string message) { base.Send(message); Console.WriteLine($"Enviando to Slack #{slackChannel}: {message}"); } } // Decorator to Discord public class DiscordDecorator : NotifierDecorator { private string discordChannel; public DiscordDecorator(INotifier notifier, string discordChannel) : base(notifier) { this.discordChannel = discordChannel; } public override void Send(string message) { base.Send(message); Console.WriteLine($"Enviando to Discord #{discordChannel}: {message}"); } } ``` ### Uso of the sistema of notificações ```csharp public class NotificationService { public void SendUrgentNotification(string message) { // Notificação básica por email INotifier notifier = new EmailNotifier("admin@company.com"); // Adicionar SMS to notificações urgentes notifier = new SMSDecorator(notifier, "+5511999999999"); // Adicionar Slack to equipe of development notifier = new SlackDecorator(notifier, "dev-alerts"); // Adicionar Discord to comunidade notifier = new DiscordDecorator(notifier, "general"); notifier.Send(message); } public void SendRegularNotification(string message) { // Apenas email to notificações regulares INotifier notifier = new EmailNotifier("team@company.com"); notifier.Send(message); } } ``` ## Exemplo Prático Sistema of processamento of dados with diferentes tipos of transformações: ```csharp // Interface to processamento of dados public interface IDataProcessor { string Process(string data); } // Processador básico public class BasicDataProcessor : IDataProcessor { public string Process(string data) { return data; } } // Decorator base public abstract class DataProcessorDecorator : IDataProcessor { protected IDataProcessor processor; public DataProcessorDecorator(IDataProcessor processor) { this.processor = processor; } public virtual string Process(string data) { return processor.Process(data); } } // Decorator to criptografia public class EncryptionDecorator : DataProcessorDecorator { public EncryptionDecorator(IDataProcessor processor) : base(processor) { } public override string Process(string data) { string processedData = base.Process(data); return Encrypt(processedData); } private string Encrypt(string data) { // Simulação of criptografia return Convert.ToBase64String(Encoding.UTF8.GetBytes(data)); } } // Decorator to compressão public class CompressionDecorator : DataProcessorDecorator { public CompressionDecorator(IDataProcessor processor) : base(processor) { } public override string Process(string data) { string processedData = base.Process(data); return Compress(processedData); } private string Compress(string data) { // Simulação of compressão return $"COMPRESSED[{data}]"; } } // Decorator to logging public class LoggingDecorator : DataProcessorDecorator { private readonly ILogger logger; public LoggingDecorator(IDataProcessor processor, ILogger logger) : base(processor) { this.logger = logger; } public override string Process(string data) { logger.Log($"Processando dados: {data.Substring(0, Math.Min(50, data.Length))}..."); var startTime = DateTime.Now; string result = base.Process(data); var duration = DateTime.Now - startTime; logger.Log($"Processamento concluído in {duration.TotalMilliseconds}ms"); return result; } } // Decorator to validação public class ValidationDecorator : DataProcessorDecorator { public ValidationDecorator(IDataProcessor processor) : base(processor) { } public override string Process(string data) { ValidateInput(data); string result = base.Process(data); ValidateOutput(result); return result; } private void ValidateInput(string data) { if (string.IsNullOrEmpty(data)) throw new ArgumentException("Dados of entrada não can ser nulos or vazios"); } private void ValidateOutput(string data) { if (string.IsNullOrEmpty(data)) throw new InvalidOperationException("Processamento resultou in dados inválidos"); } } // Uso combinado dos decorators public class DataProcessingService { private readonly ILogger logger; public DataProcessingService(ILogger logger) { this.logger = logger; } public string ProcessSensitiveData(string data) { IDataProcessor processor = new BasicDataProcessor(); // Adicionar validação processor = new ValidationDecorator(processor); // Adicionar logging processor = new LoggingDecorator(processor, logger); // Adicionar compressão processor = new CompressionDecorator(processor); // Adicionar criptografia processor = new EncryptionDecorator(processor); return processor.Process(data); } public string ProcessRegularData(string data) { IDataProcessor processor = new BasicDataProcessor(); // Apenas validação and logging to dados regulares processor = new ValidationDecorator(processor); processor = new LoggingDecorator(processor, logger); return processor.Process(data); } } ``` ## Benefícios ### 1. **Flexibilidade in tempo of execução** - Allows adicionar/remover comportamentos dinamicamente - Não requer modificação of the código existente - Configuration flexível of funcionalidades ### 2. **Princípio of the Responsabilidade Única** - Cada decorator has uma responsabilidade específica - Facilita manutenção and teste individual - Promove código mais limpo and organizado ### 3. **Composição sobre herança** - Evita hierarquias complexas of classes - Allows combinações ilimitadas of comportamentos - Reduz acoplamento entre classes ### 4. **Extensibilidade** - Novos decorators can ser adicionados facilmente - Não afeta decorators existentes - Facilita evolução of the sistema ### 5. **Reutilização** - Decorators can ser reutilizados in diferentes contextos - Promove development modular - Reduz duplicação of código ## Situações of uso ### when** utilizar:** - Adicionar responsabilidades a objetos of forma dinâmica - When herança resultaria in muitas subclasses - Implement funcionalidades opcionais or configuráveis - Sistemas of middleware or pipelines of processamento - Logging, caching, validação, autenticação transversais ### when** evitar:** - When a interface of the objeto muda frequentemente - To funcionalidades fundamentais of the objeto - When performance is crítica (overhead of chamadas) - In sistemas muito simples where herança seria suficiente