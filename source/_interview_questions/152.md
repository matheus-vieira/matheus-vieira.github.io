---
layout: interview_question
order: 152
tags:
- design-patterns
- decorator
- gof
- structural-patterns
- oop
- extensibility
- composition
- behavioral
title: How implementsr o padrão Decorator e em Which situações utilizá-lo
---

## Introduction O padrão Decorator is a padrão estrutural que allows adicionar novos withportamentos a objects existentes de forma dinâmica, envolvendo-os em objects especiais que contêm os withportamentos. is a alternativa flexível à inheritance for estender functionalities. ## Key Concept O Decorator opera no princípio de withposição about inheritance, permitindo que withportamentos sejam anexados e removesd de objects em tempo de execução. Ele mantém a mesma interface do object original, mas adiciona responsabilidades adicionais through de uma cadeia de decoradores. ## Tópicos Relevbefore ### Estrutura do padrão ```csharp // withponent - interface ou class abstrata public interface Iwithponent { string Operation(); } // Concretewithponent - implementsção base public class Concretewithponent : Iwithponent { public virtual string Operation() { return "Concretewithponent"; } } // Decorator base public abstract class BaseDecorator : Iwithponent { protected Iwithponent _withponent; public BaseDecorator(Iwithponent withponent) { _withponent = withponent; } public virtual string Operation() { return _withponent?.Operation() ?? string.Empty; } } // ConcreteDecorators - implementsções específicas public class ConcreteDecoratorA : BaseDecorator { public ConcreteDecoratorA(Iwithponent withponent) : base(withponent) { } public override string Operation() { return $"ConcreteDecoratorA({base.Operation()})"; } } public class ConcreteDecoratorB : BaseDecorator { public ConcreteDecoratorB(Iwithponent withponent) : base(withponent) { } public override string Operation() { return $"ConcreteDecoratorB({base.Operation()})"; } public string ExtraFeature() { return "ExtraFeature"; } } ``` ### Practical Example - Sistema de notificações ```csharp // interface base for notificações public interface INotifier { void Send(string message); } // implementsção básica por email public class EmailNotifier : INotifier { private string email; public EmailNotifier(string email) { this.email = email; } public void Send(string message) { Console.WriteLine($"Enviando email for {email}: {message}"); } } // Decorator base public abstract class NotifierDecorator : INotifier { protected INotifier notifier; public NotifierDecorator(INotifier notifier) { this.notifier = notifier; } public virtual void Send(string message) { notifier.Send(message); } } // Decorator for SMS public class SMSDecorator : NotifierDecorator { private string phoneNumber; public SMSDecorator(INotifier notifier, string phoneNumber) : base(notifier) { this.phoneNumber = phoneNumber; } public override void Send(string message) { base.Send(message); Console.WriteLine($"Enviando SMS for {phoneNumber}: {message}"); } } // Decorator for Slack public class SlackDecorator : NotifierDecorator { private string slackChannel; public SlackDecorator(INotifier notifier, string slackChannel) : base(notifier) { this.slackChannel = slackChannel; } public override void Send(string message) { base.Send(message); Console.WriteLine($"Enviando for Slack #{slackChannel}: {message}"); } } // Decorator for Discord public class DiscordDecorator : NotifierDecorator { private string discordChannel; public DiscordDecorator(INotifier notifier, string discordChannel) : base(notifier) { this.discordChannel = discordChannel; } public override void Send(string message) { base.Send(message); Console.WriteLine($"Enviando for Discord #{discordChannel}: {message}"); } } ``` ### Uso do sistema de notificações ```csharp public class NotificationService { public void SendUrgentNotification(string message) { // Notificação básica por email INotifier notifier = new EmailNotifier("admin@withpany.with"); // Adicionar SMS for notificações urgentes notifier = new SMSDecorator(notifier, "+5511999999999"); // Adicionar Slack for equipe de development notifier = new SlackDecorator(notifier, "dev-alerts"); // Adicionar Discord for withunidade notifier = new DiscordDecorator(notifier, "general"); notifier.Send(message); } public void SendRegularNotification(string message) { // only email for notificações regulares INotifier notifier = new EmailNotifier("team@withpany.with"); notifier.Send(message); } } ``` ## Practical Example Sistema de processesmento de dados with different tipos de transformações: ```csharp // interface for processesmento de dados public interface IDataProcessor { string Process(string data); } // processesdor basic public class BasicDataProcessor : IDataProcessor { public string Process(string data) { return data; } } // Decorator base public abstract class DataProcessorDecorator : IDataProcessor { protected IDataProcessor processor; public DataProcessorDecorator(IDataProcessor processor) { this.processor = processor; } public virtual string Process(string data) { return processor.Process(data); } } // Decorator for criptografia public class EncryptiWherecorator : DataProcessorDecorator { public EncryptiWherecorator(IDataProcessor processor) : base(processor) { } public override string Process(string data) { string processedData = base.Process(data); return Encrypt(processedData); } private string Encrypt(string data) { // Simulação de criptografia return Convert.ToBase64String(Encoding.UTF8.GetBytes(data)); } } // Decorator for withpressão public class withpressiWherecorator : DataProcessorDecorator { public withpressiWherecorator(IDataProcessor processor) : base(processor) { } public override string Process(string data) { string processedData = base.Process(data); return withpress(processedData); } private string withpress(string data) { // Simulação de withpressão return $"withPRESSED[{data}]"; } } // Decorator for logging public class LoggingDecorator : DataProcessorDecorator { private readonly ILogger logger; public LoggingDecorator(IDataProcessor processor, ILogger logger) : base(processor) { this.logger = logger; } public override string Process(string data) { logger.Log($"processesndo dados: {data.Substring(0, Math.Min(50, data.Length))}..."); var startTime = DateTime.Now; string result = base.Process(data); var duration = DateTime.Now - startTime; logger.Log($"processesmento concluído em {duration.TotalMilliseconds}ms"); return result; } } // Decorator for validação public class ValidatiWherecorator : DataProcessorDecorator { public ValidatiWherecorator(IDataProcessor processor) : base(processor) { } public override string Process(string data) { ValidateInput(data); string result = base.Process(data); ValidateOutput(result); return result; } private void ValidateInput(string data) { if (string.IsNullOrEmpty(data)) throw new ArgumentException("Dados de entrada não podem ser nulos ou vazios"); } private void ValidateOutput(string data) { if (string.IsNullOrEmpty(data)) throw new InvalidOperationException("processesmento resultou em dados inválidos"); } } // Uso withbinado dos decorators public class DataProcessingService { private readonly ILogger logger; public DataProcessingService(ILogger logger) { this.logger = logger; } public string ProcessSensitiveData(string data) { IDataProcessor processor = new BasicDataProcessor(); // Adicionar validação processor = new ValidatiWherecorator(processor); // Adicionar logging processor = new LoggingDecorator(processor, logger); // Adicionar withpressão processor = new withpressiWherecorator(processor); // Adicionar criptografia processor = new EncryptiWherecorator(processor); return processor.Process(data); } public string ProcessRegularData(string data) { IDataProcessor processor = new BasicDataProcessor(); // only validação e logging for dados regulares processor = new ValidatiWherecorator(processor); processor = new LoggingDecorator(processor, logger); return processor.Process(data); } } ``` ## benefits ### 1. **Flexibilidade em tempo de execução** - allows adicionar/removesr withportamentos dinamicamente - Não requer modificação do code existente - configuresção flexível de functionalities ### 2. **Princípio da Responsabilidade Única** - each decorator tem uma responsabilidade específica - facilitates manutenção e testing individual - Promove code mais limpo e organizado ### 3. **withposição about inheritance** - avoids hierarquias withplexas de classs - allows withbinações ilimitadas de withportamentos - reduces acoplamento between classs ### 4. **Extensibilidade** - Novos decorators podem ser adicionados facilmente - Não afeta decorators existentes - facilitates evolução do sistema ### 5. **Reutilização** - Decorators podem ser reutilizados em different contextos - Promove development modular - reduces duplicação de code ## Situações de uso ### **When utilizar:** - Adicionar responsabilidades a objects de forma dinâmica - When inheritance resultaria em many subclasss - implementsr functionalities opcionais ou configuráveis - Sistemas de middleware ou pipelines de processesmento - Logging, caching, validação, autenticação transversais ### **When avoidsr:** - When a interface do object muda frequentemente - for functionalities fundamentais do object - When performance é crítica (overhead de chamadas) - Em sistemas muito simple Where inheritance seria suficiente