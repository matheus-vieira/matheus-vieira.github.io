---
layout: interview_question
order: 154
tags:
- design-patterns
- observer
- gof
- behavioral-patterns
- events
- thread-safety
- performance
- notifications
title: How implementsr o padrão Observer de forma efficient e thread-safe
---

## Introduction O padrão Observer is a padrão withportamental que define uma relação de dependência um-for-many between objects, permitindo que múltiplos objects sejam automaticamente notificados When o estado de um object observado muda. A implementsção efficient e thread-safe é crucial em environments concorrentes modernos. ## Key Concept O Observer estabelece um mecanismo de notificação loose-coupled Where o subject (observado) mantém uma lista de observers (observadores) e os notifica automaticamente about mudanças de estado. A eficiência e thread-safety são alcançadas through de técnicas How copy-on-iteration, weak references, e mecanismos de sincronização suitable. ## Tópicos Relevbefore ### implementsção básica thread-safe ```csharp // interface do Observer public interface IObserver<T> { void Update(T data); } // interface do Subject public interface ISubject<T> { void Subscribe(IObserver<T> observer); void Unsubscribe(IObserver<T> observer); void Notify(T data); } // implementsção thread-safe with ReaderWriterLockSlim public class ThreadSafeSubject<T> : ISubject<T> { private readonly HashSet<IObserver<T>> _observers; private readonly ReaderWriterLockSlim _lock; public ThreadSafeSubject() { _observers = new HashSet<IObserver<T>>(); _lock = new ReaderWriterLockSlim(LockRecursionPolicy.NoRecursion); } public void Subscribe(IObserver<T> observer) { if (observer == null) throw new ArgumentNullException(nameof(observer)); _lock.EnterWriteLock(); try { _observers.Add(observer); } finally { _lock.ExitWriteLock(); } } public void Unsubscribe(IObserver<T> observer) { if (observer == null) return; _lock.EnterWriteLock(); try { _observers.removes(observer); } finally { _lock.ExitWriteLock(); } } public void Notify(T data) { // Copy-on-iteration pattern for thread-safety IObserver<T>[] observersCopy; _lock.EnterReadLock(); try { observersCopy = _observers.ToArray(); } finally { _lock.ExitReadLock(); } // Notificar fora do lock for avoidsr deadlocks foreach (var observer in observersCopy) { try { observer.Update(data); } catch (Exception ex) { // Log exception mas continue notificando other observers OnObserverException?.Invoke(observer, ex); } } } public event Action<IObserver<T>, Exception> OnObserverException; public void Dispose() { _lock?.EnterWriteLock(); try { _observers?.Clear(); } finally { _lock?.ExitWriteLock(); _lock?.Dispose(); } } } ``` ### implementsção with Weak References ```csharp // Observer with weak references for avoidsr vazamentos de memória public class WeakReferenceSubject<T> : ISubject<T> { private readonly List<WeakReference<IObserver<T>>> _observers; private readonly object _lock = new object(); public WeakReferenceSubject() { _observers = new List<WeakReference<IObserver<T>>>(); } public void Subscribe(IObserver<T> observer) { if (observer == null) throw new ArgumentNullException(nameof(observer)); lock (_lock) { // removes referencias mortas before de adicionar nova CleanupDeadReferences(); _observers.Add(new WeakReference<IObserver<T>>(observer)); } } public void Unsubscribe(IObserver<T> observer) { if (observer == null) return; lock (_lock) { for (int i = _observers.Count - 1; i >= 0; i--) { if (_observers[i].TryGetTarget(out var target) && ReferenceEWhichs(target, observer)) { _observers.removesAt(i); break; } } } } public void Notify(T data) { List<IObserver<T>> activeObservers; lock (_lock) { activeObservers = new List<IObserver<T>>(_observers.Count); for (int i = _observers.Count - 1; i >= 0; i--) { if (_observers[i].TryGetTarget(out var observer)) { activeObservers.Add(observer); } else { // removes referência morta _observers.removesAt(i); } } } // Notificar fora do lock forllel.ForEach(activeObservers, observer => { try { observer.Update(data); } catch (Exception ex) { OnObserverException?.Invoke(observer, ex); } }); } private void CleanupDeadReferences() { for (int i = _observers.Count - 1; i >= 0; i--) { if (!_observers[i].TryGetTarget(out _)) { _observers.removesAt(i); } } } public event Action<IObserver<T>, Exception> OnObserverException; } ``` ### implementsção with Async/Await ```csharp // Observer assíncrono public interface IAsyncObserver<T> { Task UpdateAsync(T data, CancellationToken cancellationToken = default); } public class AsyncSubject<T> : IDisposable { private readonly ConcurrentBag<IAsyncObserver<T>> _observers; private readonly withoutaphoreSlim _withoutaphore; public AsyncSubject() { _observers = new ConcurrentBag<IAsyncObserver<T>>(); _withoutaphore = new withoutaphoreSlim(1, 1); } public async Task SubscribeAsync(IAsyncObserver<T> observer) { if (observer == null) throw new ArgumentNullException(nameof(observer)); await _withoutaphore.WaitAsync(); try { _observers.Add(observer); } finally { _withoutaphore.Release(); } } public async Task NotifyAsync(T data, CancellationToken cancellationToken = default) { var observers = _observers.ToArray(); var tasks = observers.Select(async observer => { try { await observer.UpdateAsync(data, cancellationToken); } catch (Exception ex) { OnObserverException?.Invoke(observer, ex); } }); await Task.WhenAll(tasks); } public async Task NotifyAsync(T data, TimeSpan timeout) { using (var cts = new CancellationTokenSource(timeout)) { await NotifyAsync(data, cts.Token); } } public event Action<IAsyncObserver<T>, Exception> OnObserverException; public void Dispose() { _withoutaphore?.Dispose(); } } ``` ## Practical Example Sistema de monitoring de preços de ações with different tipos de observers: ```csharp // Modelo de dados public class StockPrice { public string Symbol { get; set; } public decimal Price { get; set; } public decimal Change { get; set; } public DateTime Timestamp { get; set; } } // Observer for logging public class StockPriceLogger : IObserver<StockPrice> { private readonly ILogger _logger; public StockPriceLogger(ILogger logger) { _logger = logger; } public void Update(StockPrice data) { _logger.Log($"[{data.Timestamp}] {data.Symbol}: ${data.Price} ({data.Change:+0.00;-0.00;0.00})"); } } // Observer for alertas public class StockPriceAlertService : IAsyncObserver<StockPrice> { private readonly INotificationService _notificationService; private readonly Dictionary<string, decimal> _alertThresholds; public StockPriceAlertService(INotificationService notificationService) { _notificationService = notificationService; _alertThresholds = new Dictionary<string, decimal>(); } public void SetAlert(string symbol, decimal threshold) { _alertThresholds[symbol] = threshold; } public async Task UpdateAsync(StockPrice data, CancellationToken cancellationToken = default) { if (_alertThresholds.TryGetValue(data.Symbol, out var threshold)) { if (Math.Abs(data.Change) >= threshold) { var message = $"ALERT: {data.Symbol} moved {data.Change:+0.00;-0.00;0.00} to ${data.Price}"; await _notificationService.SendAlertAsync(message, cancellationToken); } } } } // Observer for cache/storage public class StockPriceCache : IObserver<StockPrice> { private readonly ConcurrentDictionary<string, StockPrice> _cache; private readonly IRepository<StockPrice> _repository; public StockPriceCache(IRepository<StockPrice> repository) { _cache = new ConcurrentDictionary<string, StockPrice>(); _repository = repository; } public void Update(StockPrice data) { // updatesr cache _cache.AddOrUpdate(data.Symbol, data, (key, oldValue) => data); // Persistir de forma assíncrona (fire-and-forget) Task.Run(async () => { try { await _repository.SaveAsync(data); } catch (Exception ex) { // Log error but don't throw Console.WriteLine($"Error saving stock price: {ex.Message}"); } }); } public StockPrice GetLatestPrice(string symbol) { _cache.TryGetValue(symbol, out var price); return price; } } // Sistema main de monitoring public class StockPriceMonitor : IDisposable { private readonly ThreadSafeSubject<StockPrice> _syncSubject; private readonly AsyncSubject<StockPrice> _asyncSubject; private readonly Timer _priceUpdateTimer; private readonly Random _random = new Random(); public StockPriceMonitor() { _syncSubject = new ThreadSafeSubject<StockPrice>(); _asyncSubject = new AsyncSubject<StockPrice>(); // Simular updates de preço _priceUpdateTimer = new Timer(SimulatePriceUpdate, null, TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1)); } public void SubscribeSync(IObserver<StockPrice> observer) { _syncSubject.Subscribe(observer); } public async Task SubscribeAsync(IAsyncObserver<StockPrice> observer) { await _asyncSubject.SubscribeAsync(observer); } private async void SimulatePriceUpdate(object state) { var symbols = new[] { "AAPL", "GOOGL", "MSFT", "AMZN" }; var symbol = symbols[_random.Next(symbols.Length)]; var price = new StockPrice { Symbol = symbol, Price = 100 + _random.Next(-50, 51), Change = (_random.NextDouble() - 0.5) * 10, Timestamp = DateTime.UtcNow }; // Notificar observers síncronos _syncSubject.Notify(price); // Notificar observers assíncronos await _asyncSubject.NotifyAsync(price, TimeSpan.FromSeconds(5)); } public void Dispose() { _priceUpdateTimer?.Dispose(); _syncSubject?.Dispose(); _asyncSubject?.Dispose(); } } // Uso do sistema public class StockMonitoringService { public async Task StartMonitoringAsync() { var monitor = new StockPriceMonitor(); var logger = new ConsoleLogger(); var notificationService = new EmailNotificationService(); var repository = new SqlStockPriceRepository(); // configuresr observers var priceLogger = new StockPriceLogger(logger); var alertService = new StockPriceAlertService(notificationService); var priceCache = new StockPriceCache(repository); // configuresr alertas alertService.SetAlert("AAPL", 5.0m); alertService.SetAlert("GOOGL", 10.0m); // Registrar observers monitor.SubscribeSync(priceLogger); monitor.SubscribeSync(priceCache); await monitor.SubscribeAsync(alertService); // Manter sistema rodando Console.WriteLine("monitoring iniciado. Pressione Whichquer tecla for forr..."); Console.ReadKey(); monitor.Dispose(); } } ``` ## benefits ### 1. **Thread-Safety** - ReaderWriterLockSlim for performance optimizesda em scenarios read-heavy - Copy-on-iteration previne modificações concorrentes during notificação - Tratamento de exceções isolado avoids corrupção de estado ### 2. **management de Memória** - Weak references previnem vazamentos de memória - Cleanup automático de referências mortas - Disposable pattern for liberação adequada de resources ### 3. **Performance** - forlelização de notificações When apropriado - Minimização de tempo em locks críticos - optimizesções for scenarios read-heavy vs write-heavy ### 4. **Robustez** - Tratamento de exceções não afeta other observers - Timeouts for operações assíncronas - Cancellation tokens for operações longas ### 5. **Flexibilidade** - Suporte tanto for operações síncronas quanto assíncronas - different estruntilgias de notificação - Extensibilidade through de interfaces bem definidas ## Considerações de implementsção ### **choice da estruntilgia de sincronização:** - `lock` simple for casos basic - `ReaderWriterLockSlim` for scenarios read-heavy - `ConcurrentCollection` for operações lock-free When possível ### **Weak vs Strong References:** - Weak references for prevenir vazamentos de memória - Strong references When lifecycle é controlsdo explicitamente ### **Notificação Síncrona vs Assíncrona:** - Síncrona for operações rápidas e determinísticas - Assíncrona for operações I/O ou processesmento pesado ### **Tratamento de Exceções:** - failure isolation between observers - Logging adequado for debugging - Recovery gracioso When possível