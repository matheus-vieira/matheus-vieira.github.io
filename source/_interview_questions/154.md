--- layout: interview_question title: how" implement o padrão Observer of forma eficiente and thread-safe" tags: [design-patterns, observer, gof, behavioral-patterns, events, thread-safety, performance, notifications] order: 154 --- ## Introdução O padrão Observer is um padrão comportamental que define uma relação of dependência um-para-muitos entre objetos, permitindo que múltiplos objetos sejam automaticamente notificados when o estado of um objeto observado muda. A implementation eficiente and thread-safe is crucial in ambientes concorrentes modernos. ## Conceito-chave O Observer estabelece um mecanismo of notificação loose-coupled where o subject (observado) mantém uma lista of observers (observadores) and os notifica automaticamente sobre mudanças of estado. A eficiência and thread-safety are alcançadas through of técnicas how copy-on-iteration, weak references, and mecanismos of sincronização adequados. ## Tópicos Relevantes ### Implementation básica thread-safe ```csharp // Interface of the Observer public interface IObserver<T> { void Update(T data); } // Interface of the Subject public interface ISubject<T> { void Subscribe(IObserver<T> observer); void Unsubscribe(IObserver<T> observer); void Notify(T data); } // Implementation thread-safe with ReaderWriterLockSlim public class ThreadSafeSubject<T> : ISubject<T> { private readonly HashSet<IObserver<T>> _observers; private readonly ReaderWriterLockSlim _lock; public ThreadSafeSubject() { _observers = new HashSet<IObserver<T>>(); _lock = new ReaderWriterLockSlim(LockRecursionPolicy.NoRecursion); } public void Subscribe(IObserver<T> observer) { if (observer == null) throw new ArgumentNullException(nameof(observer)); _lock.EnterWriteLock(); try { _observers.Add(observer); } finally { _lock.ExitWriteLock(); } } public void Unsubscribe(IObserver<T> observer) { if (observer == null) return; _lock.EnterWriteLock(); try { _observers.Remove(observer); } finally { _lock.ExitWriteLock(); } } public void Notify(T data) { // Copy-on-iteration pattern to thread-safety IObserver<T>[] observersCopy; _lock.EnterReadLock(); try { observersCopy = _observers.ToArray(); } finally { _lock.ExitReadLock(); } // Notificar fora of the lock to evitar deadlocks foreach (var observer in observersCopy) { try { observer.Update(data); } catch (Exception ex) { // Log exception mas continue notificando outros observers OnObserverException?.Invoke(observer, ex); } } } public event Action<IObserver<T>, Exception> OnObserverException; public void Dispose() { _lock?.EnterWriteLock(); try { _observers?.Clear(); } finally { _lock?.ExitWriteLock(); _lock?.Dispose(); } } } ``` ### Implementation with Weak References ```csharp // Observer with weak references to evitar vazamentos of memória public class WeakReferenceSubject<T> : ISubject<T> { private readonly List<WeakReference<IObserver<T>>> _observers; private readonly object _lock = new object(); public WeakReferenceSubject() { _observers = new List<WeakReference<IObserver<T>>>(); } public void Subscribe(IObserver<T> observer) { if (observer == null) throw new ArgumentNullException(nameof(observer)); lock (_lock) { // Remove referencias mortas antes of adicionar nova CleanupDeadReferences(); _observers.Add(new WeakReference<IObserver<T>>(observer)); } } public void Unsubscribe(IObserver<T> observer) { if (observer == null) return; lock (_lock) { for (int i = _observers.Count - 1; i >= 0; i--) { if (_observers[i].TryGetTarget(out var target) && ReferenceEquals(target, observer)) { _observers.RemoveAt(i); break; } } } } public void Notify(T data) { List<IObserver<T>> activeObservers; lock (_lock) { activeObservers = new List<IObserver<T>>(_observers.Count); for (int i = _observers.Count - 1; i >= 0; i--) { if (_observers[i].TryGetTarget(out var observer)) { activeObservers.Add(observer); } else { // Remove referência morta _observers.RemoveAt(i); } } } // Notificar fora of the lock Parallel.ForEach(activeObservers, observer => { try { observer.Update(data); } catch (Exception ex) { OnObserverException?.Invoke(observer, ex); } }); } private void CleanupDeadReferences() { for (int i = _observers.Count - 1; i >= 0; i--) { if (!_observers[i].TryGetTarget(out _)) { _observers.RemoveAt(i); } } } public event Action<IObserver<T>, Exception> OnObserverException; } ``` ### Implementation with Async/Await ```csharp // Observer assíncrono public interface IAsyncObserver<T> { Task UpdateAsync(T data, CancellationToken cancellationToken = default); } public class AsyncSubject<T> : IDisposable { private readonly ConcurrentBag<IAsyncObserver<T>> _observers; private readonly SemaphoreSlim _semaphore; public AsyncSubject() { _observers = new ConcurrentBag<IAsyncObserver<T>>(); _semaphore = new SemaphoreSlim(1, 1); } public async Task SubscribeAsync(IAsyncObserver<T> observer) { if (observer == null) throw new ArgumentNullException(nameof(observer)); await _semaphore.WaitAsync(); try { _observers.Add(observer); } finally { _semaphore.Release(); } } public async Task NotifyAsync(T data, CancellationToken cancellationToken = default) { var observers = _observers.ToArray(); var tasks = observers.Select(async observer => { try { await observer.UpdateAsync(data, cancellationToken); } catch (Exception ex) { OnObserverException?.Invoke(observer, ex); } }); await Task.WhenAll(tasks); } public async Task NotifyAsync(T data, TimeSpan timeout) { using (var cts = new CancellationTokenSource(timeout)) { await NotifyAsync(data, cts.Token); } } public event Action<IAsyncObserver<T>, Exception> OnObserverException; public void Dispose() { _semaphore?.Dispose(); } } ``` ## Exemplo Prático Sistema of monitoring of preços of ações with diferentes tipos of observers: ```csharp // Modelo of dados public class StockPrice { public string Symbol { get; set; } public decimal Price { get; set; } public decimal Change { get; set; } public DateTime Timestamp { get; set; } } // Observer to logging public class StockPriceLogger : IObserver<StockPrice> { private readonly ILogger _logger; public StockPriceLogger(ILogger logger) { _logger = logger; } public void Update(StockPrice data) { _logger.Log($"[{data.Timestamp}] {data.Symbol}: ${data.Price} ({data.Change:+0.00;-0.00;0.00})"); } } // Observer to alertas public class StockPriceAlertService : IAsyncObserver<StockPrice> { private readonly INotificationService _notificationService; private readonly Dictionary<string, decimal> _alertThresholds; public StockPriceAlertService(INotificationService notificationService) { _notificationService = notificationService; _alertThresholds = new Dictionary<string, decimal>(); } public void SetAlert(string symbol, decimal threshold) { _alertThresholds[symbol] = threshold; } public async Task UpdateAsync(StockPrice data, CancellationToken cancellationToken = default) { if (_alertThresholds.TryGetValue(data.Symbol, out var threshold)) { if (Math.Abs(data.Change) >= threshold) { var message = $"ALERT: {data.Symbol} moved {data.Change:+0.00;-0.00;0.00} to ${data.Price}"; await _notificationService.SendAlertAsync(message, cancellationToken); } } } } // Observer to cache/armazenamento public class StockPriceCache : IObserver<StockPrice> { private readonly ConcurrentDictionary<string, StockPrice> _cache; private readonly IRepository<StockPrice> _repository; public StockPriceCache(IRepository<StockPrice> repository) { _cache = new ConcurrentDictionary<string, StockPrice>(); _repository = repository; } public void Update(StockPrice data) { // Atualizar cache _cache.AddOrUpdate(data.Symbol, data, (key, oldValue) => data); // Persistir of forma assíncrona (fire-and-forget) Task.Run(async () => { try { await _repository.SaveAsync(data); } catch (Exception ex) { // Log error but don't throw Console.WriteLine($"Error saving stock price: {ex.Message}"); } }); } public StockPrice GetLatestPrice(string symbol) { _cache.TryGetValue(symbol, out var price); return price; } } // Sistema principal of monitoring public class StockPriceMonitor : IDisposable { private readonly ThreadSafeSubject<StockPrice> _syncSubject; private readonly AsyncSubject<StockPrice> _asyncSubject; private readonly Timer _priceUpdateTimer; private readonly Random _random = new Random(); public StockPriceMonitor() { _syncSubject = new ThreadSafeSubject<StockPrice>(); _asyncSubject = new AsyncSubject<StockPrice>(); // Simular atualizações of preço _priceUpdateTimer = new Timer(SimulatePriceUpdate, null, TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1)); } public void SubscribeSync(IObserver<StockPrice> observer) { _syncSubject.Subscribe(observer); } public async Task SubscribeAsync(IAsyncObserver<StockPrice> observer) { await _asyncSubject.SubscribeAsync(observer); } private async void SimulatePriceUpdate(object state) { var symbols = new[] { "AAPL", "GOOGL", "MSFT", "AMZN" }; var symbol = symbols[_random.Next(symbols.Length)]; var price = new StockPrice { Symbol = symbol, Price = 100 + _random.Next(-50, 51), Change = (_random.NextDouble() - 0.5) * 10, Timestamp = DateTime.UtcNow }; // Notificar observers síncronos _syncSubject.Notify(price); // Notificar observers assíncronos await _asyncSubject.NotifyAsync(price, TimeSpan.FromSeconds(5)); } public void Dispose() { _priceUpdateTimer?.Dispose(); _syncSubject?.Dispose(); _asyncSubject?.Dispose(); } } // Uso of the sistema public class StockMonitoringService { public async Task StartMonitoringAsync() { var monitor = new StockPriceMonitor(); var logger = new ConsoleLogger(); var notificationService = new EmailNotificationService(); var repository = new SqlStockPriceRepository(); // Configure observers var priceLogger = new StockPriceLogger(logger); var alertService = new StockPriceAlertService(notificationService); var priceCache = new StockPriceCache(repository); // Configure alertas alertService.SetAlert("AAPL", 5.0m); alertService.SetAlert("GOOGL", 10.0m); // Registrar observers monitor.SubscribeSync(priceLogger); monitor.SubscribeSync(priceCache); await monitor.SubscribeAsync(alertService); // Manter sistema rodando Console.WriteLine("Monitoramento iniciado. Pressione qualquer tecla to parar..."); Console.ReadKey(); monitor.Dispose(); } } ``` ## Benefícios ### 1. **Thread-Safety** - ReaderWriterLockSlim to performance otimizada in cenários read-heavy - Copy-on-iteration previne modificações concorrentes durante notificação - Tratamento of exceções isolado evita corrupção of estado ### 2. management** of Memória** - Weak references previnem vazamentos of memória - Cleanup automático of referências mortas - Disposable pattern to liberação adequada of resources ### 3. **Performance** - Paralelização of notificações when apropriado - Minimização of tempo in locks críticos - Otimizações to cenários read-heavy vs write-heavy ### 4. **Robustez** - Tratamento of exceções não afeta outros observers - Timeouts to operações assíncronas - Cancellation tokens to operações longas ### 5. **Flexibilidade** - Suporte tanto to operações síncronas quanto assíncronas - Diferentes estratégias of notificação - Extensibilidade through of interfaces bem definidas ## Considerações of Implementation ### **Escolha of the estratégia of sincronização:** - `lock` simples to casos básicos - `ReaderWriterLockSlim` to cenários read-heavy - `ConcurrentCollection` to operações lock-free when possível ### **Weak vs Strong References:** - Weak references to prevenir vazamentos of memória - Strong references when lifecycle is controlado explicitamente ### **Notificação Síncrona vs Assíncrona:** - Síncrona to operações rápidas and determinísticas - Assíncrona to operações I/O or processamento pesado ### **Tratamento of Exceções:** - Isolamento of falhas entre observers - Logging adequado to debugging - Recovery gracioso when possível