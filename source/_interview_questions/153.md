--- layout: interview_question title: "Diferenças entre SQL Server and PostgreSQL and when usar cada um" tags: [sql-server, postgresql, database, rdbms, comparison, performance, licensing, features] order: 153 --- ## Introdução SQL Server and PostgreSQL are dois dos principais sistemas of management of banco of dados relacionais (RDBMS) of the mercado. Enquanto o SQL Server is um produto comercial of the Microsoft, o PostgreSQL is um banco of dados open-source. Cada um has características únicas que os tornam adequados to diferentes cenários and necessidades empresariais. ## Conceito-chave A escolha entre SQL Server and PostgreSQL should considerar fatores how licenciamento, performance, resources específicos, ecossistema tecnológico, suporte of the comunidade, and requisitos of compliance. Ambos are robustos and adequados to applications enterprise, mas diferem significativamente in filosofia, custo and características técnicas. ## Tópicos Relevantes ### Licenciamento and Custo **SQL Server:** - Licenciamento comercial of the Microsoft - Modelos of licenciamento: Core-based, Server+CAL - Versões: Express (gratuita with limitações), Standard, Enterprise - Custos can ser significativos to implementações grandes **PostgreSQL:** - Completamente open-source (licença PostgreSQL) - Gratuito to uso comercial - Without limitações of funcionalidades por licença - Custos relacionados apenas a suporte and infraestrutura ### Performance and Escalabilidade ```sql -- SQL Server - Resources avançados of performance -- Columnstore indexes to analytics CREATE CLUSTERED COLUMNSTORE INDEX CCI_Sales ON Sales.SalesOrderDetail; -- Query hints específicos SELECT * FROM Sales.Customer WITH (NOLOCK) WHERE CustomerID = 123; -- Particionamento avançado CREATE PARTITION FUNCTION PF_Date (datetime2) AS RANGE RIGHT FOR VALUES ('2023-01-01', '2023-02-01', '2023-03-01'); ``` ```sql -- PostgreSQL - Resources of performance -- Índices avançados (GiST, GIN, BRIN) CREATE INDEX CONCURRENTLY idx_products_search ON products USING GIN(to_tsvector('english', description)); -- Particionamento declarativo (PostgreSQL 10+) CREATE TABLE sales_2023 PARTITION OF sales FOR VALUES FROM ('2023-01-01') TO ('2024-01-01'); -- Parallel queries automáticas SET max_parallel_workers_per_gather = 4; ``` ### Resources específicos **SQL Server características únicas:** ```sql -- T-SQL with resources avançados -- Common Table Expressions recursivas WITH HierarchyData AS ( SELECT EmployeeID, ManagerID, Name, 0 as Level FROM Employees WHERE ManagerID IS NULL UNION ALL SELECT e.EmployeeID, e.ManagerID, e.Name, h.Level + 1 FROM Employees and INNER JOIN HierarchyData h ON e.ManagerID = h.EmployeeID ) SELECT * FROM HierarchyData; -- Merge statement Merge Sales.Target AS target USING Sales.Source AS source ON target.ID = source.ID WHEN MATCHED THEN UPDATE SET target.Amount = source.Amount WHEN NOT MATCHED THEN INSERT (ID, Amount) VALUES (source.ID, source.Amount); -- XML nativo SELECT customer_data.value('(/Customer/Name)[1]', 'varchar(50)') as CustomerName FROM CustomerXML; ``` **PostgreSQL características únicas:** ```sql -- Arrays nativos CREATE TABLE products ( id SERIAL PRIMARY KEY, tags TEXT[], prices DECIMAL[] ); INSERT INTO products (tags, prices) VALUES (ARRAY['electronics', 'mobile'], ARRAY[999.99, 1299.99]); -- JSON/JSONB nativo CREATE TABLE events ( id SERIAL PRIMARY KEY, data JSONB ); SELECT data->>'event_type' as event_type, data->'user'->>'name' as user_name FROM events WHERE data @> '{"status": "active"}'; -- Window functions avançadas SELECT product_name, sales_amount, PERCENT_RANK() OVER (ORDER BY sales_amount) as percentile, CUME_DIST() OVER (ORDER BY sales_amount) as cumulative_dist FROM sales; -- Extensões customizadas CREATE EXTENSION IF NOT EXISTS postgis; -- To dados geoespaciais CREATE EXTENSION IF NOT EXISTS pg_trgm; -- To busca fuzzy ``` ### Integration with ecossistemas **SQL Server - Ecossistema Microsoft:** ```csharp // Entity Framework Core with SQL Server public class ApplicationDbContext : DbContext { protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) { optionsBuilder.UseSqlServer(connectionString); } protected override void OnModelCreating(ModelBuilder modelBuilder) { // Resources específicos of the SQL Server modelBuilder.Entity<Customer>() .Property(e => e.CustomerData) .HasColumnType("xml"); modelBuilder.Entity<Product>() .HasIndex(e => e.Description) .HasMethod("FULLTEXT"); } } ``` **PostgreSQL - Multiplataforma:** ```python # Python with PostgreSQL import psycopg2 from sqlalchemy import create_engine import pandas as pd # Conexão direta conn = psycopg2.connect( host="localhost", database="myapp", user="postgres", password="password" ) # With SQLAlchemy engine = create_engine('postgresql://user:password@localhost/dbname') # Aproveitando resources específicos of the PostgreSQL query = """ SELECT product_name, similarity(product_name, 'smartphone') as similarity_score FROM products WHERE product_name % 'smartphone' ORDER BY similarity_score DESC; """ df = pd.read_sql(query, engine) ``` ## Exemplo Prático Comparação of implementation of um sistema of auditoria: ### SQL Server Implementation ```sql -- Criação of tabela with resources of the SQL Server CREATE TABLE AuditLog ( ID bigint IDENTITY(1,1) PRIMARY KEY, TableName nvarchar(128) NOT NULL, Operation char(1) NOT NULL, -- I, U, D OldValues xml, NewValues xml, ChangedBy nvarchar(256) DEFAULT SUSER_SNAME(), ChangedDate datetime2 DEFAULT GETUTCDATE(), SessionInfo xml DEFAULT ( SELECT @@SPID as SessionID, APP_NAME() as ApplicationName, HOST_NAME() as HostName FOR XML PATH('Session') ) ); -- Trigger of auditoria CREATE TRIGGER tr_Customer_Audit ON Customers AFTER INSERT, UPDATE, DELETE AS BEGIN SET NOCOUNT ON; -- INSERT IF EXISTS(SELECT 1 FROM inserted) AND NOT EXISTS(SELECT 1 FROM deleted) BEGIN INSERT INTO AuditLog (TableName, Operation, NewValues) SELECT 'Customers', 'I', (SELECT * FROM inserted FOR XML PATH('Row')) END -- UPDATE IF EXISTS(SELECT 1 FROM inserted) AND EXISTS(SELECT 1 FROM deleted) BEGIN INSERT INTO AuditLog (TableName, Operation, OldValues, NewValues) SELECT 'Customers', 'U', (SELECT * FROM deleted FOR XML PATH('Row')), (SELECT * FROM inserted FOR XML PATH('Row')) END -- DELETE IF NOT EXISTS(SELECT 1 FROM inserted) AND EXISTS(SELECT 1 FROM deleted) BEGIN INSERT INTO AuditLog (TableName, Operation, OldValues) SELECT 'Customers', 'D', (SELECT * FROM deleted FOR XML PATH('Row')) END END; ``` ### PostgreSQL Implementation ```sql -- Criação of tabela with resources of the PostgreSQL CREATE TABLE audit_log ( id BIGSERIAL PRIMARY KEY, table_name TEXT NOT NULL, operation CHAR(1) NOT NULL, old_values JSONB, new_values JSONB, changed_by TEXT DEFAULT current_user, changed_date TIMESTAMPTZ DEFAULT now(), session_info JSONB DEFAULT jsonb_build_object( 'pid', pg_backend_pid(), 'application_name', current_setting('application_name'), 'client_addr', inet_client_addr() ) ); -- Function of auditoria genérica CREATE OR REPLACE FUNCTION audit_trigger_function() RETURNS TRIGGER AS $$ BEGIN IF TG_OP = 'INSERT' THEN INSERT INTO audit_log (table_name, operation, new_values) VALUES (TG_TABLE_NAME, 'I', row_to_json(NEW)::jsonb); RETURN NEW; ELSIF TG_OP = 'UPDATE' THEN INSERT INTO audit_log (table_name, operation, old_values, new_values) VALUES (TG_TABLE_NAME, 'U', row_to_json(OLD)::jsonb, row_to_json(NEW)::jsonb); RETURN NEW; ELSIF TG_OP = 'DELETE' THEN INSERT INTO audit_log (table_name, operation, old_values) VALUES (TG_TABLE_NAME, 'D', row_to_json(OLD)::jsonb); RETURN OLD; END IF; RETURN NULL; END; $$ LANGUAGE plpgsql; -- Aplicar trigger a qualquer tabela CREATE TRIGGER customers_audit_trigger AFTER INSERT OR UPDATE OR DELETE ON customers FOR EACH ROW EXECUTE FUNCTION audit_trigger_function(); -- Consulta avançada with JSONB SELECT table_name, operation, changed_date, new_values->>'customer_name' as customer_name, new_values->>'email' as email FROM audit_log WHERE table_name = 'customers' AND operation = 'I' AND new_values @> '{"status": "active"}' AND changed_date >= now() - interval '7 days' ORDER BY changed_date DESC; ``` ## Benefícios ### SQL Server **Vantagens:** - Integration profunda with ecossistema Microsoft - Ferramentas administrativas robustas (SSMS, SSRS, SSIS) - Suporte empresarial completo of the Microsoft - Performance excelente to workloads Windows - Resources avançados of BI and Analytics - AlwaysOn Availability Groups to alta disponibilidade when** usar:** - Ambiente predominantemente Microsoft - Necessidade of suporte empresarial garantido - Integration with Active Directory essencial - Uso intensivo of ferramentas Microsoft BI - Applications .NET que se beneficiam of the integration nativa ### PostgreSQL **Vantagens:** - Completamente gratuito and open-source - Extensibilidade through of plugins - Conformidade rigorosa with padrões SQL - Excelente to dados semi-estruturados (JSON) - Comunidade ativa and inovadora - Multiplataforma (Linux, Windows, macOS) - Resources avançados of geometria and full-text search when** usar:** - Orçamento limitado or preferência por open-source - Ambiente multi-plataforma - Necessidade of tipos of dados avançados - Applications with dados semi-estruturados - Sistemas que se beneficiam of extensões customizadas - Projetos que valorizam conformidade with padrões SQL ### Comparação of Performance **SQL Server:** - Otimizado to Windows - Excelente performance in workloads OLTP - Columnstore to analytics - In-Memory OLTP to cargas críticas **PostgreSQL:** - Performance consistente in múltiplas plataformas - Excelente to queries complexas - Paralelização automática of queries - Extensões to casos específicos (TimescaleDB to time-series) ### Considerações of Deploy **SQL Server:** - Licenciamento can ser complexo - Custos can escalar significativamente - Dependência of the ecossistema Microsoft - Ferramentas administrativas amadurecidas **PostgreSQL:** - Deploy mais flexível and econômico - Maior variedade of options of hosting - Requer mais conhecimento técnico to optimization - Comunidade forte mas suporte comercial opcional