---
layout: interview_question
order: 153
tags:
- sql-server
- postgresql
- database
- rdbms
- comparison
- performance
- licensing
- features
title: Diferenças between SQL Server e PostgreSQL e When usar each one
---

## Introduction SQL Server e PostgreSQL are two dos main systems de management de database relacionais (RDBMS) do mercado. while o SQL Server is a withmercial product da Microsoft, o PostgreSQL is a database open-source. each one has unique features que os make suitable for different scenarios e business needs. ## Key Concept A choice between SQL Server e PostgreSQL should consider factors How licensing, performance, specific features, ecossistema tecnological, suporte da withunidade, e requirements de withpliance. Ambos são robustos e suitable for applications enterprise, mas diferem significativamente em filosofia, cost e features técnicas. ## Tópicos Relevbefore ### licensing e cost **SQL Server:** - licensing withercial da Microsoft - Modelos de licensing: Core-based, Server+CAL - versions: Express (gratuita with limitations), Standard, Enterprise - costs podem ser significativos for implementsções grandes **PostgreSQL:** - withpletamente open-source (licença PostgreSQL) - Gratuito for uso withercial - without limitations de functionalities por licença - costs related only a suporte e infrastructure ### Performance e scalability ```sql -- SQL Server - resources advanced de performance -- Columnstore indexes for analytics CREATE CLUSTERED COLUMNSTORE INDEX CCI_Sales ON Sales.SalesOrderDetail; -- Query hints específicos SELECT * FROM Sales.costmer WITH (NOLOCK) WHERE costmerID = 123; -- Particionamento advanced CREATE PARTITION FUNCTION PF_Date (datetime2) AS RANGE RIGHT FOR VALUES ('2023-01-01', '2023-02-01', '2023-03-01'); ``` ```sql -- PostgreSQL - resources de performance -- Índices advanced (GiST, GIN, BRIN) CREATE INDEX CONCURRENTLY idx_products_search ON products USING GIN(to_tsvector('english', description)); -- Particionamento declarativo (PostgreSQL 10+) CREATE TABLE sales_2023 PARTITION OF sales FOR VALUES FROM ('2023-01-01') TO ('2024-01-01'); -- forllel queries automáticas SET max_forllel_workers_per_gather = 4; ``` ### specific features **SQL Server unique features:** ```sql -- T-SQL with resources advanced -- withmon Table Expressions recursivas WITH HierarchyData AS ( SELECT EmployeeID, ManagerID, Name, 0 as Level FROM Employees WHERE ManagerID IS NULL UNION ALL SELECT e.EmployeeID, e.ManagerID, e.Name, h.Level + 1 FROM Employees e INNER JOIN HierarchyData h ON e.ManagerID = h.EmployeeID ) SELECT * FROM HierarchyData; -- merge statement merge Sales.Target AS target USING Sales.Source AS source ON target.ID = source.ID WHEN MATCHED THEN UPDATE SET target.Amount = source.Amount WHEN NOT MATCHED THEN INSERT (ID, Amount) VALUES (source.ID, source.Amount); -- XML nativo SELECT costmer_data.value('(/costmer/Name)[1]', 'varchar(50)') as costmerName FROM costmerXML; ``` **PostgreSQL unique features:** ```sql -- Arrays nativos CREATE TABLE products ( id SERIAL PRIMARY KEY, tags TEXT[], prices DECIMAL[] ); INSERT INTO products (tags, prices) VALUES (ARRAY['electronics', 'mobile'], ARRAY[999.99, 1299.99]); -- JSON/JSONB nativo CREATE TABLE events ( id SERIAL PRIMARY KEY, data JSONB ); SELECT data->>'event_type' as event_type, data->'user'->>'name' as user_name FROM events WHERE data @> '{"status": "active"}'; -- Window functions avançadas SELECT product_name, sales_amount, PERCENT_RANK() OVER (ORDER BY sales_amount) as percentile, CUME_DIST() OVER (ORDER BY sales_amount) as cumulative_dist FROM sales; -- Extensões costmizadas CREATE EXTENSION IF NOT EXISTS postgis; -- for dados geoespaciais CREATE EXTENSION IF NOT EXISTS pg_trgm; -- for busca fuzzy ``` ### Integração with ecossistemas **SQL Server - Ecossistema Microsoft:** ```csharp // Entity framework Core with SQL Server public class ApplicationDbContext : DbContext { protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) { optionsBuilder.UseSqlServer(connectionString); } protected override void OnModelCreating(ModelBuilder modelBuilder) { // specific features do SQL Server modelBuilder.Entity<costmer>() .Property(e => e.costmerData) .HasColumnType("xml"); modelBuilder.Entity<Product>() .HasIndex(e => e.Description) .HasMethod("FULLTEXT"); } } ``` **PostgreSQL - Multiplatform:** ```python # Python with PostgreSQL import psycopg2 from sqlalchemy import create_engine import pandas as pd # Conexão direta conn = psycopg2.connect( host="localhost", database="myapp", user="postgres", password="password" ) # with SQLAlchemy engine = create_engine('postgresql://user:password@localhost/dbname') # Aproveitando specific features do PostgreSQL query = """ SELECT product_name, similarity(product_name, 'smartphone') as similarity_score FROM products WHERE product_name % 'smartphone' ORDER BY similarity_score DESC; """ df = pd.read_sql(query, engine) ``` ## Practical Example withforção de implementsção de um sistema de audit: ### SQL Server implementstion ```sql -- createsção de tabela with resources do SQL Server CREATE TABLE AuditLog ( ID bigint IDENTITY(1,1) PRIMARY KEY, TableName nvarchar(128) NOT NULL, Operation char(1) NOT NULL, -- I, U, D OldValues xml, NewValues xml, ChangedBy nvarchar(256) DEFAULT SUSER_SNAME(), ChangedDate datetime2 DEFAULT GETUTCDATE(), SessionInfo xml DEFAULT ( SELECT @@SPID as SessionID, APP_NAME() as ApplicationName, HOST_NAME() as HostName FOR XML PATH('Session') ) ); -- Trigger de audit CREATE TRIGGER tr_costmer_Audit ON costmers AFTER INSERT, UPDATE, DELETE AS BEGIN SET NOCOUNT ON; -- INSERT IF EXISTS(SELECT 1 FROM inserted) AND NOT EXISTS(SELECT 1 FROM deleted) BEGIN INSERT INTO AuditLog (TableName, Operation, NewValues) SELECT 'costmers', 'I', (SELECT * FROM inserted FOR XML PATH('Row')) END -- UPDATE IF EXISTS(SELECT 1 FROM inserted) AND EXISTS(SELECT 1 FROM deleted) BEGIN INSERT INTO AuditLog (TableName, Operation, OldValues, NewValues) SELECT 'costmers', 'U', (SELECT * FROM deleted FOR XML PATH('Row')), (SELECT * FROM inserted FOR XML PATH('Row')) END -- DELETE IF NOT EXISTS(SELECT 1 FROM inserted) AND EXISTS(SELECT 1 FROM deleted) BEGIN INSERT INTO AuditLog (TableName, Operation, OldValues) SELECT 'costmers', 'D', (SELECT * FROM deleted FOR XML PATH('Row')) END END; ``` ### PostgreSQL implementstion ```sql -- createsção de tabela with resources do PostgreSQL CREATE TABLE audit_log ( id BIGSERIAL PRIMARY KEY, table_name TEXT NOT NULL, operation CHAR(1) NOT NULL, old_values JSONB, new_values JSONB, changed_by TEXT DEFAULT current_user, changed_date TIMESTAMPTZ DEFAULT now(), session_info JSONB DEFAULT jsonb_build_object( 'pid', pg_backend_pid(), 'application_name', current_setting('application_name'), 'client_addr', inet_client_addr() ) ); -- function de audit genérica CREATE OR REPLACE FUNCTION audit_trigger_function() RETURNS TRIGGER AS $$ BEGIN IF TG_OP = 'INSERT' THEN INSERT INTO audit_log (table_name, operation, new_values) VALUES (TG_TABLE_NAME, 'I', row_to_json(NEW)::jsonb); RETURN NEW; ELSIF TG_OP = 'UPDATE' THEN INSERT INTO audit_log (table_name, operation, old_values, new_values) VALUES (TG_TABLE_NAME, 'U', row_to_json(OLD)::jsonb, row_to_json(NEW)::jsonb); RETURN NEW; ELSIF TG_OP = 'DELETE' THEN INSERT INTO audit_log (table_name, operation, old_values) VALUES (TG_TABLE_NAME, 'D', row_to_json(OLD)::jsonb); RETURN OLD; END IF; RETURN NULL; END; $$ LANGUAGE plpgsql; -- apply trigger a Whichquer tabela CREATE TRIGGER costmers_audit_trigger AFTER INSERT OR UPDATE OR DELETE ON costmers FOR EACH ROW EXECUTE FUNCTION audit_trigger_function(); -- Consulta avançada with JSONB SELECT table_name, operation, changed_date, new_values->>'costmer_name' as costmer_name, new_values->>'email' as email FROM audit_log WHERE table_name = 'costmers' AND operation = 'I' AND new_values @> '{"status": "active"}' AND changed_date >= now() - interval '7 days' ORDER BY changed_date DESC; ``` ## benefits ### SQL Server **advantages:** - Integração profunda with ecossistema Microsoft - Ferramentas administrativas robustas (SSMS, SSRS, SSIS) - Suporte empresarial withpleto da Microsoft - Performance excelente for workloads Windows - resources advanced de BI e Analytics - AlwaysOn Availability Groups for alta availability **When usar:** - environment predominantemente Microsoft - need de suporte empresarial garantido - Integração with Active Directory essential - Uso intensivo de ferramentas Microsoft BI - applications .NET que se beneficiam da integração nativa ### PostgreSQL **advantages:** - withpletamente gratuito e open-source - Extensibilidade through de plugins - Conformidade rigorosa with padrões SQL - Excelente for dados withouti-estruturados (JSON) - withunidade ativa e inovadora - Multiplatform (Linux, Windows, macOS) - resources advanced de geometria e full-text search **When usar:** - Orçamento limitado ou preferência por open-source - environment multi-platform - need de tipos de dados advanced - applications with dados withouti-estruturados - Sistemas que se beneficiam de extensões costmizadas - projects que valorizam conformidade with padrões SQL ### withforção de Performance **SQL Server:** - optimizesdo for Windows - Excelente performance em workloads OLTP - Columnstore for analytics - In-Memory OLTP for cargas críticas **PostgreSQL:** - Performance consistente em múltiplas platforms - Excelente for queries withplexas - forlelização automática de queries - Extensões for casos específicos (TimescaleDB for time-series) ### Considerações de Deploy **SQL Server:** - licensing pode ser withplex - costs podem escalar significativamente - Dependência do ecossistema Microsoft - Ferramentas administrativas amadurecidas **PostgreSQL:** - Deploy mais flexível e econômico - Maior variedade de opções de hosting - Requer mais conhecimento técnico for optimizesção - withunidade forte mas suporte withercial opcional