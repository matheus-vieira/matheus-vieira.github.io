<p>As a .NET backend developer, I’ve discovered that certain design patterns consistently prove their worth in real-world applications. Today, I want to share three patterns that have become essential tools in my development arsenal: <strong>Repository</strong>, <strong>Strategy</strong>, and <strong>Mediator</strong> patterns.</p>

<p>These aren’t just theoretical concepts—they’re practical solutions that I implement daily to create more maintainable, testable, and scalable applications.</p>

<h2 id="1-repository-pattern-clean-data-access">1. Repository Pattern: Clean Data Access</h2>

<p>The Repository pattern creates a uniform interface for accessing data, regardless of the underlying storage mechanism.</p>

<h3 id="why-repository-pattern-works">Why Repository Pattern Works</h3>

<ul>
  <li><strong>Testability</strong>: Easy to mock for unit tests</li>
  <li><strong>Separation of Concerns</strong>: Business logic stays independent of data access</li>
  <li><strong>Flexibility</strong>: Switch between different data sources without breaking business logic</li>
</ul>

<h3 id="repository-implementation-example">Repository Implementation Example</h3>

<pre><code class="language-csharp">public interface IUserRepository
{
    Task&lt;User&gt; GetByIdAsync(int id);
    Task&lt;IEnumerable&lt;User&gt;&gt; GetAllAsync();
    Task&lt;User&gt; CreateAsync(User user);
    Task UpdateAsync(User user);
    Task DeleteAsync(int id);
}

public class UserRepository : IUserRepository
{
    private readonly ApplicationDbContext _context;

    public UserRepository(ApplicationDbContext context)
    {
        _context = context;
    }

    public async Task&lt;User&gt; GetByIdAsync(int id)
    {
        return await _context.Users
            .FirstOrDefaultAsync(u =&gt; u.Id == id);
    }

    public async Task&lt;IEnumerable&lt;User&gt;&gt; GetAllAsync()
    {
        return await _context.Users
            .ToListAsync();
    }

    // Other methods...
}
</code></pre>

<h3 id="repository-pattern-benefits">Repository Pattern Benefits</h3>

<p>In a recent project, we needed to migrate from SQL Server to CosmosDB. Thanks to the Repository pattern, we only had to implement a new repository class—zero changes to business logic.</p>

<h2 id="2-strategy-pattern-flexible-business-logic">2. Strategy Pattern: Flexible Business Logic</h2>

<p>The Strategy pattern allows you to define a family of algorithms, encapsulate them, and make them interchangeable at runtime.</p>

<h3 id="why-strategy-pattern-excels">Why Strategy Pattern Excels</h3>

<ul>
  <li><strong>Open/Closed Principle</strong>: Add new strategies without modifying existing code</li>
  <li><strong>Runtime Flexibility</strong>: Choose algorithms based on context</li>
  <li><strong>Testability</strong>: Test each strategy in isolation</li>
</ul>

<h3 id="strategy-implementation-example">Strategy Implementation Example</h3>

<pre><code class="language-csharp">public interface IPaymentProcessor
{
    Task&lt;PaymentResult&gt; ProcessAsync(PaymentRequest request);
    bool CanProcess(PaymentMethod method);
}

public class CreditCardProcessor : IPaymentProcessor
{
    public async Task&lt;PaymentResult&gt; ProcessAsync(PaymentRequest request)
    {
        // Credit card processing logic
        return await ProcessCreditCardAsync(request);
    }

    public bool CanProcess(PaymentMethod method)
        =&gt; method == PaymentMethod.CreditCard;
}

public class PixProcessor : IPaymentProcessor
{
    public async Task&lt;PaymentResult&gt; ProcessAsync(PaymentRequest request)
    {
        // PIX processing logic
        return await ProcessPixAsync(request);
    }

    public bool CanProcess(PaymentMethod method)
        =&gt; method == PaymentMethod.Pix;
}

public class PaymentService
{
    private readonly IEnumerable&lt;IPaymentProcessor&gt; _processors;

    public PaymentService(IEnumerable&lt;IPaymentProcessor&gt; processors)
    {
        _processors = processors;
    }

    public async Task&lt;PaymentResult&gt; ProcessPaymentAsync(PaymentRequest request)
    {
        var processor = _processors
            .FirstOrDefault(p =&gt; p.CanProcess(request.Method));

        if (processor == null)
            throw new NotSupportedException($"Payment method {request.Method} not supported");

        return await processor.ProcessAsync(request);
    }
}
</code></pre>

<h3 id="strategy-pattern-benefits">Strategy Pattern Benefits</h3>

<p>When we needed to add new payment methods, we simply created new processor classes. The existing code remained untouched, and testing was straightforward since each processor is independent.</p>

<h2 id="3-mediator-pattern-decoupled-communication">3. Mediator Pattern: Decoupled Communication</h2>

<p>The Mediator pattern defines how a set of objects interact with each other, promoting loose coupling by preventing objects from referring to each other explicitly.</p>

<h3 id="why-mediator-pattern-works">Why Mediator Pattern Works</h3>

<ul>
  <li><strong>Decoupling</strong>: Components don’t need to know about each other</li>
  <li><strong>Single Responsibility</strong>: Each handler focuses on one specific task</li>
  <li><strong>Cross-cutting Concerns</strong>: Easy to add validation, logging, caching through behaviors</li>
</ul>

<h3 id="implementation-with-mediatr">Implementation with MediatR</h3>

<pre><code class="language-csharp">public class CreateUserCommand : IRequest&lt;UserDto&gt;
{
    public string Name { get; set; }
    public string Email { get; set; }
}

public class CreateUserCommandHandler : IRequestHandler&lt;CreateUserCommand, UserDto&gt;
{
    private readonly IUserRepository _userRepository;
    private readonly IMapper _mapper;

    public CreateUserCommandHandler(IUserRepository userRepository, IMapper mapper)
    {
        _userRepository = userRepository;
        _mapper = mapper;
    }

    public async Task&lt;UserDto&gt; Handle(CreateUserCommand request, CancellationToken cancellationToken)
    {
        var user = new User
        {
            Name = request.Name,
            Email = request.Email,
            CreatedAt = DateTime.UtcNow
        };

        var createdUser = await _userRepository.CreateAsync(user);
        return _mapper.Map&lt;UserDto&gt;(createdUser);
    }
}

// In your controller
[ApiController]
[Route("api/[controller]")]
public class UsersController : ControllerBase
{
    private readonly IMediator _mediator;

    public UsersController(IMediator mediator)
    {
        _mediator = mediator;
    }

    [HttpPost]
    public async Task&lt;ActionResult&lt;UserDto&gt;&gt; CreateUser(CreateUserCommand command)
    {
        var result = await _mediator.Send(command);
        return Ok(result);
    }
}
</code></pre>

<h3 id="adding-cross-cutting-concerns">Adding Cross-Cutting Concerns</h3>

<pre><code class="language-csharp">public class LoggingBehavior&lt;TRequest, TResponse&gt; : IPipelineBehavior&lt;TRequest, TResponse&gt;
{
    private readonly ILogger&lt;LoggingBehavior&lt;TRequest, TResponse&gt;&gt; _logger;

    public LoggingBehavior(ILogger&lt;LoggingBehavior&lt;TRequest, TResponse&gt;&gt; logger)
    {
        _logger = logger;
    }

    public async Task&lt;TResponse&gt; Handle(TRequest request, RequestHandlerDelegate&lt;TResponse&gt; next, CancellationToken cancellationToken)
    {
        _logger.LogInformation("Handling {RequestName}", typeof(TRequest).Name);
        var response = await next();
        _logger.LogInformation("Handled {RequestName}", typeof(TRequest).Name);
        return response;
    }
}
</code></pre>

<h3 id="mediator-pattern-benefits">Mediator Pattern Benefits</h3>

<p>The Mediator pattern transformed our controllers from fat, complex classes into thin coordinators. Adding logging, validation, and caching became trivial through pipeline behaviors.</p>

<h2 id="dependency-injection-setup">Dependency Injection Setup</h2>

<p>Here’s how I typically register these patterns in <code>Program.cs</code>:</p>

<pre><code class="language-csharp">// Repository Pattern
builder.Services.AddScoped&lt;IUserRepository, UserRepository&gt;();

// Strategy Pattern
builder.Services.AddScoped&lt;IPaymentProcessor, CreditCardProcessor&gt;();
builder.Services.AddScoped&lt;IPaymentProcessor, PixProcessor&gt;();
builder.Services.AddScoped&lt;PaymentService&gt;();

// Mediator Pattern
builder.Services.AddMediatR(cfg =&gt; cfg.RegisterServicesFromAssembly(typeof(Program).Assembly));
builder.Services.AddTransient(typeof(IPipelineBehavior&lt;,&gt;), typeof(LoggingBehavior&lt;,&gt;));
</code></pre>

<h2 id="when-not-to-use-these-patterns">When NOT to Use These Patterns</h2>

<p><strong>Repository Pattern</strong>: Skip it if you’re using Entity Framework with a simple CRUD application. EF already provides abstraction.</p>

<p><strong>Strategy Pattern</strong>: Don’t overcomplicate simple if/else scenarios. Use it when you have complex algorithms or expect frequent changes.</p>

<p><strong>Mediator Pattern</strong>: Avoid it for very simple applications. The overhead might not be worth it if you don’t have complex business logic.</p>

<h2 id="key-takeaways">Key Takeaways</h2>

<ol>
  <li><strong>Repository Pattern</strong> provides clean data access abstraction</li>
  <li><strong>Strategy Pattern</strong> enables flexible, runtime-configurable algorithms</li>
  <li><strong>Mediator Pattern</strong> decouples components and centralizes business logic</li>
</ol>

<p>These patterns have consistently made my .NET applications more maintainable, testable, and adaptable to changing requirements. They’re not silver bullets, but when applied appropriately, they can significantly improve your codebase quality.</p>

<h2 id="whats-next">What’s Next?</h2>

<p>In my next post, I’ll dive deeper into building event-driven ingestion pipelines in .NET, showing how these patterns work together in a real-world architecture.</p>

<p>Have you used these patterns in your projects? What other patterns do you find essential in .NET development? Let me know in the comments!</p>

<hr />

<p><em>This post is part of my “.NET &amp; Azure Foundations” series. Follow along as I share practical insights from building scalable backend systems.</em></p>
