<h2 id="introdução">Introdução</h2>

<p>O padrão Decorator é um padrão estrutural que permite adicionar novos comportamentos a objetos existentes de forma dinâmica, envolvendo-os em objetos especiais que contêm os comportamentos. É uma alternativa flexível à herança para estender funcionalidades.</p>

<h2 id="conceito-chave">Conceito-chave</h2>

<p>O Decorator opera no princípio de composição sobre herança, permitindo que comportamentos sejam anexados e removidos de objetos em tempo de execução. Ele mantém a mesma interface do objeto original, mas adiciona responsabilidades adicionais através de uma cadeia de decoradores.</p>

<h2 id="tópicos-relevantes">Tópicos Relevantes</h2>

<h3 id="estrutura-do-padrão">Estrutura do padrão</h3>

<pre><code class="language-csharp">// Component - interface ou classe abstrata
public interface IComponent
{
    string Operation();
}

// ConcreteComponent - implementação base
public class ConcreteComponent : IComponent
{
    public virtual string Operation()
    {
        return "ConcreteComponent";
    }
}

// Decorator base
public abstract class BaseDecorator : IComponent
{
    protected IComponent _component;

    public BaseDecorator(IComponent component)
    {
        _component = component;
    }

    public virtual string Operation()
    {
        return _component?.Operation() ?? string.Empty;
    }
}

// ConcreteDecorators - implementações específicas
public class ConcreteDecoratorA : BaseDecorator
{
    public ConcreteDecoratorA(IComponent component) : base(component) { }

    public override string Operation()
    {
        return $"ConcreteDecoratorA({base.Operation()})";
    }
}

public class ConcreteDecoratorB : BaseDecorator
{
    public ConcreteDecoratorB(IComponent component) : base(component) { }

    public override string Operation()
    {
        return $"ConcreteDecoratorB({base.Operation()})";
    }

    public string ExtraFeature()
    {
        return "ExtraFeature";
    }
}
</code></pre>

<h3 id="exemplo-prático---sistema-de-notificações">Exemplo prático - Sistema de notificações</h3>

<pre><code class="language-csharp">// Interface base para notificações
public interface INotifier
{
    void Send(string message);
}

// Implementação básica por email
public class EmailNotifier : INotifier
{
    private string email;

    public EmailNotifier(string email)
    {
        this.email = email;
    }

    public void Send(string message)
    {
        Console.WriteLine($"Enviando email para {email}: {message}");
    }
}

// Decorator base
public abstract class NotifierDecorator : INotifier
{
    protected INotifier notifier;

    public NotifierDecorator(INotifier notifier)
    {
        this.notifier = notifier;
    }

    public virtual void Send(string message)
    {
        notifier.Send(message);
    }
}

// Decorator para SMS
public class SMSDecorator : NotifierDecorator
{
    private string phoneNumber;

    public SMSDecorator(INotifier notifier, string phoneNumber) 
        : base(notifier)
    {
        this.phoneNumber = phoneNumber;
    }

    public override void Send(string message)
    {
        base.Send(message);
        Console.WriteLine($"Enviando SMS para {phoneNumber}: {message}");
    }
}

// Decorator para Slack
public class SlackDecorator : NotifierDecorator
{
    private string slackChannel;

    public SlackDecorator(INotifier notifier, string slackChannel) 
        : base(notifier)
    {
        this.slackChannel = slackChannel;
    }

    public override void Send(string message)
    {
        base.Send(message);
        Console.WriteLine($"Enviando para Slack #{slackChannel}: {message}");
    }
}

// Decorator para Discord
public class DiscordDecorator : NotifierDecorator
{
    private string discordChannel;

    public DiscordDecorator(INotifier notifier, string discordChannel) 
        : base(notifier)
    {
        this.discordChannel = discordChannel;
    }

    public override void Send(string message)
    {
        base.Send(message);
        Console.WriteLine($"Enviando para Discord #{discordChannel}: {message}");
    }
}
</code></pre>

<h3 id="uso-do-sistema-de-notificações">Uso do sistema de notificações</h3>

<pre><code class="language-csharp">public class NotificationService
{
    public void SendUrgentNotification(string message)
    {
        // Notificação básica por email
        INotifier notifier = new EmailNotifier("admin@company.com");

        // Adicionar SMS para notificações urgentes
        notifier = new SMSDecorator(notifier, "+5511999999999");

        // Adicionar Slack para equipe de desenvolvimento
        notifier = new SlackDecorator(notifier, "dev-alerts");

        // Adicionar Discord para comunidade
        notifier = new DiscordDecorator(notifier, "general");

        notifier.Send(message);
    }

    public void SendRegularNotification(string message)
    {
        // Apenas email para notificações regulares
        INotifier notifier = new EmailNotifier("team@company.com");
        notifier.Send(message);
    }
}
</code></pre>

<h2 id="exemplo-prático">Exemplo Prático</h2>

<p>Sistema de processamento de dados com diferentes tipos de transformações:</p>

<pre><code class="language-csharp">// Interface para processamento de dados
public interface IDataProcessor
{
    string Process(string data);
}

// Processador básico
public class BasicDataProcessor : IDataProcessor
{
    public string Process(string data)
    {
        return data;
    }
}

// Decorator base
public abstract class DataProcessorDecorator : IDataProcessor
{
    protected IDataProcessor processor;

    public DataProcessorDecorator(IDataProcessor processor)
    {
        this.processor = processor;
    }

    public virtual string Process(string data)
    {
        return processor.Process(data);
    }
}

// Decorator para criptografia
public class EncryptionDecorator : DataProcessorDecorator
{
    public EncryptionDecorator(IDataProcessor processor) : base(processor) { }

    public override string Process(string data)
    {
        string processedData = base.Process(data);
        return Encrypt(processedData);
    }

    private string Encrypt(string data)
    {
        // Simulação de criptografia
        return Convert.ToBase64String(Encoding.UTF8.GetBytes(data));
    }
}

// Decorator para compressão
public class CompressionDecorator : DataProcessorDecorator
{
    public CompressionDecorator(IDataProcessor processor) : base(processor) { }

    public override string Process(string data)
    {
        string processedData = base.Process(data);
        return Compress(processedData);
    }

    private string Compress(string data)
    {
        // Simulação de compressão
        return $"COMPRESSED[{data}]";
    }
}

// Decorator para logging
public class LoggingDecorator : DataProcessorDecorator
{
    private readonly ILogger logger;

    public LoggingDecorator(IDataProcessor processor, ILogger logger) 
        : base(processor)
    {
        this.logger = logger;
    }

    public override string Process(string data)
    {
        logger.Log($"Processando dados: {data.Substring(0, Math.Min(50, data.Length))}...");
        
        var startTime = DateTime.Now;
        string result = base.Process(data);
        var duration = DateTime.Now - startTime;
        
        logger.Log($"Processamento concluído em {duration.TotalMilliseconds}ms");
        return result;
    }
}

// Decorator para validação
public class ValidationDecorator : DataProcessorDecorator
{
    public ValidationDecorator(IDataProcessor processor) : base(processor) { }

    public override string Process(string data)
    {
        ValidateInput(data);
        string result = base.Process(data);
        ValidateOutput(result);
        return result;
    }

    private void ValidateInput(string data)
    {
        if (string.IsNullOrEmpty(data))
            throw new ArgumentException("Dados de entrada não podem ser nulos ou vazios");
    }

    private void ValidateOutput(string data)
    {
        if (string.IsNullOrEmpty(data))
            throw new InvalidOperationException("Processamento resultou em dados inválidos");
    }
}

// Uso combinado dos decorators
public class DataProcessingService
{
    private readonly ILogger logger;

    public DataProcessingService(ILogger logger)
    {
        this.logger = logger;
    }

    public string ProcessSensitiveData(string data)
    {
        IDataProcessor processor = new BasicDataProcessor();
        
        // Adicionar validação
        processor = new ValidationDecorator(processor);
        
        // Adicionar logging
        processor = new LoggingDecorator(processor, logger);
        
        // Adicionar compressão
        processor = new CompressionDecorator(processor);
        
        // Adicionar criptografia
        processor = new EncryptionDecorator(processor);

        return processor.Process(data);
    }

    public string ProcessRegularData(string data)
    {
        IDataProcessor processor = new BasicDataProcessor();
        
        // Apenas validação e logging para dados regulares
        processor = new ValidationDecorator(processor);
        processor = new LoggingDecorator(processor, logger);

        return processor.Process(data);
    }
}
</code></pre>

<h2 id="benefícios">Benefícios</h2>

<h3 id="1-flexibilidade-em-tempo-de-execução">1. <strong>Flexibilidade em tempo de execução</strong></h3>
<ul>
  <li>Permite adicionar/remover comportamentos dinamicamente</li>
  <li>Não requer modificação do código existente</li>
  <li>Configuração flexível de funcionalidades</li>
</ul>

<h3 id="2-princípio-da-responsabilidade-única">2. <strong>Princípio da Responsabilidade Única</strong></h3>
<ul>
  <li>Cada decorator tem uma responsabilidade específica</li>
  <li>Facilita manutenção e teste individual</li>
  <li>Promove código mais limpo e organizado</li>
</ul>

<h3 id="3-composição-sobre-herança">3. <strong>Composição sobre herança</strong></h3>
<ul>
  <li>Evita hierarquias complexas de classes</li>
  <li>Permite combinações ilimitadas de comportamentos</li>
  <li>Reduz acoplamento entre classes</li>
</ul>

<h3 id="4-extensibilidade">4. <strong>Extensibilidade</strong></h3>
<ul>
  <li>Novos decorators podem ser adicionados facilmente</li>
  <li>Não afeta decorators existentes</li>
  <li>Facilita evolução do sistema</li>
</ul>

<h3 id="5-reutilização">5. <strong>Reutilização</strong></h3>
<ul>
  <li>Decorators podem ser reutilizados em diferentes contextos</li>
  <li>Promove desenvolvimento modular</li>
  <li>Reduz duplicação de código</li>
</ul>

<h2 id="situações-de-uso">Situações de uso</h2>

<h3 id="quando-utilizar"><strong>Quando utilizar:</strong></h3>
<ul>
  <li>Adicionar responsabilidades a objetos de forma dinâmica</li>
  <li>Quando herança resultaria em muitas subclasses</li>
  <li>Implementar funcionalidades opcionais ou configuráveis</li>
  <li>Sistemas de middleware ou pipelines de processamento</li>
  <li>Logging, caching, validação, autenticação transversais</li>
</ul>

<h3 id="quando-evitar"><strong>Quando evitar:</strong></h3>
<ul>
  <li>Quando a interface do objeto muda frequentemente</li>
  <li>Para funcionalidades fundamentais do objeto</li>
  <li>Quando performance é crítica (overhead de chamadas)</li>
  <li>Em sistemas muito simples onde herança seria suficiente</li>
</ul>
